-- ===========================================
-- AGENT PROMPTS FEATURE
-- AI-powered prompt generation for task tickets
-- ===========================================

-- ===========================================
-- ENUMS
-- ===========================================

CREATE TYPE prompt_turn_status AS ENUM (
  'PENDING_RESPONSE',
  'ANALYZING',
  'COMPLETED',
  'NEEDS_FOLLOW_UP'
);

CREATE TYPE agent_session_status AS ENUM (
  'ACTIVE',
  'COMPLETED',
  'ABANDONED'
);

-- Extend task_activity_kind for agent prompt events
ALTER TYPE task_activity_kind ADD VALUE IF NOT EXISTS 'AGENT_PROMPT_GENERATED';
ALTER TYPE task_activity_kind ADD VALUE IF NOT EXISTS 'AGENT_RESPONSE_ANALYZED';
ALTER TYPE task_activity_kind ADD VALUE IF NOT EXISTS 'AGENT_AUTO_STATUS_UPDATE';

-- ===========================================
-- AGENT PROMPT SESSIONS
-- Tracks a prompt/response conversation per repo per task
-- ===========================================

CREATE TABLE public.agent_prompt_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  project_id UUID NOT NULL REFERENCES public.projects(id) ON DELETE CASCADE,
  repo_id UUID NOT NULL REFERENCES public.repos(id) ON DELETE CASCADE,
  created_by UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status agent_session_status NOT NULL DEFAULT 'ACTIVE',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(task_id, repo_id)  -- One session per task+repo combination
);

CREATE INDEX agent_prompt_sessions_task_idx ON public.agent_prompt_sessions (task_id);
CREATE INDEX agent_prompt_sessions_repo_idx ON public.agent_prompt_sessions (repo_id);
CREATE INDEX agent_prompt_sessions_project_idx ON public.agent_prompt_sessions (project_id);

-- ===========================================
-- AGENT PROMPT TURNS
-- Tracks each prompt/response cycle within a session
-- ===========================================

CREATE TABLE public.agent_prompt_turns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES public.agent_prompt_sessions(id) ON DELETE CASCADE,
  turn_number INTEGER NOT NULL,
  status prompt_turn_status NOT NULL DEFAULT 'PENDING_RESPONSE',

  -- The prompt generated by LanePilot
  prompt_content TEXT NOT NULL,
  prompt_metadata JSONB DEFAULT '{}',  -- Store context pack ref, checklist items, etc.

  -- User-pasted response from their AI agent
  agent_response TEXT,
  agent_tool TEXT CHECK (agent_tool IN ('cursor', 'claude-code', 'copilot', 'aider', 'windsurf', 'other')),
  response_pasted_at TIMESTAMPTZ,

  -- Analysis of the response
  analysis_result JSONB,  -- {success, completedItems, failedItems, notes, etc.}
  suggested_status_update TEXT,  -- Suggested task status change
  suggested_doc_updates JSONB,  -- [{slug, action, description}]

  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,

  UNIQUE(session_id, turn_number)
);

CREATE INDEX agent_prompt_turns_session_idx ON public.agent_prompt_turns (session_id, turn_number);
CREATE INDEX agent_prompt_turns_status_idx ON public.agent_prompt_turns (status);

-- ===========================================
-- ROW LEVEL SECURITY
-- ===========================================

ALTER TABLE public.agent_prompt_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.agent_prompt_turns ENABLE ROW LEVEL SECURITY;

-- Sessions RLS
CREATE POLICY "Project members can view agent prompt sessions"
  ON public.agent_prompt_sessions FOR SELECT
  USING (public.is_project_member(project_id));

CREATE POLICY "Project members can create agent prompt sessions"
  ON public.agent_prompt_sessions FOR INSERT
  WITH CHECK (public.is_project_member(project_id) AND auth.uid() = created_by);

CREATE POLICY "Session creators and maintainers can update sessions"
  ON public.agent_prompt_sessions FOR UPDATE
  USING (
    created_by = auth.uid() OR
    EXISTS (
      SELECT 1 FROM public.project_members pm
      WHERE pm.project_id = agent_prompt_sessions.project_id
        AND pm.user_id = auth.uid()
        AND pm.role IN ('OWNER', 'MAINTAINER')
    )
  );

CREATE POLICY "Session creators and maintainers can delete sessions"
  ON public.agent_prompt_sessions FOR DELETE
  USING (
    created_by = auth.uid() OR
    EXISTS (
      SELECT 1 FROM public.project_members pm
      WHERE pm.project_id = agent_prompt_sessions.project_id
        AND pm.user_id = auth.uid()
        AND pm.role IN ('OWNER', 'MAINTAINER')
    )
  );

-- Helper function to check session membership
CREATE OR REPLACE FUNCTION public.is_session_member(p_session_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.agent_prompt_sessions s
    JOIN public.project_members pm ON s.project_id = pm.project_id
    WHERE s.id = p_session_id AND pm.user_id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Turns RLS
CREATE POLICY "Project members can view turns"
  ON public.agent_prompt_turns FOR SELECT
  USING (public.is_session_member(session_id));

CREATE POLICY "Project members can create turns"
  ON public.agent_prompt_turns FOR INSERT
  WITH CHECK (public.is_session_member(session_id));

CREATE POLICY "Project members can update turns"
  ON public.agent_prompt_turns FOR UPDATE
  USING (public.is_session_member(session_id));

CREATE POLICY "Project members can delete turns"
  ON public.agent_prompt_turns FOR DELETE
  USING (public.is_session_member(session_id));

-- ===========================================
-- TRIGGERS
-- ===========================================

-- Update updated_at on session changes
CREATE TRIGGER update_agent_prompt_sessions_updated_at
  BEFORE UPDATE ON public.agent_prompt_sessions
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Auto-increment turn number
CREATE OR REPLACE FUNCTION public.set_turn_number()
RETURNS TRIGGER AS $$
DECLARE
  v_max_turn INTEGER;
BEGIN
  IF NEW.turn_number IS NULL OR NEW.turn_number = 0 THEN
    SELECT COALESCE(MAX(turn_number), 0) + 1 INTO v_max_turn
    FROM public.agent_prompt_turns
    WHERE session_id = NEW.session_id;

    NEW.turn_number := v_max_turn;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER set_turn_number_trigger
  BEFORE INSERT ON public.agent_prompt_turns
  FOR EACH ROW EXECUTE FUNCTION public.set_turn_number();

-- Update session updated_at when turns change
CREATE OR REPLACE FUNCTION public.update_session_on_turn_change()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.agent_prompt_sessions
  SET updated_at = NOW()
  WHERE id = COALESCE(NEW.session_id, OLD.session_id);
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER update_session_on_turn_insert
  AFTER INSERT ON public.agent_prompt_turns
  FOR EACH ROW EXECUTE FUNCTION public.update_session_on_turn_change();

CREATE TRIGGER update_session_on_turn_update
  AFTER UPDATE ON public.agent_prompt_turns
  FOR EACH ROW EXECUTE FUNCTION public.update_session_on_turn_change();
